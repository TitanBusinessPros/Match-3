<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match-3 Game</title>
    <link rel="icon" type="image/png" href="https://github.com/TitanBusinessPros/Match-3/raw/main/Match-3-Favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .container {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-logo {
            max-width: 400px;
            width: 100%;
            height: auto;
            margin-bottom: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .score {
            font-size: 1.5em;
            color: #764ba2;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .level-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 20px;
        }

        .level-box {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .level-box h3 {
            font-size: 0.9em;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .level-box .value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }

        .level-complete {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .level-complete.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .level-complete h2 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .level-complete p {
            font-size: 1.3em;
            color: #666;
            margin-bottom: 20px;
        }

        .grid {
            display: inline-grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 4px;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 15px;
            box-shadow: inset 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .tile {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .tile.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            border: 3px solid white;
        }

        .tile.matched {
            animation: match 0.5s ease-out;
        }

        @keyframes match {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }

        .color-0 { background: linear-gradient(135deg, #ff6b6b, #ee5a6f); }
        .color-1 { background: linear-gradient(135deg, #4ecdc4, #44a08d); }
        .color-2 { background: linear-gradient(135deg, #ffd93d, #f6c744); }
        .color-3 { background: linear-gradient(135deg, #a29bfe, #6c5ce7); }
        .color-4 { background: linear-gradient(135deg, #fd79a8, #e84393); }
        .color-5 { background: linear-gradient(135deg, #74b9ff, #0984e3); }

        button {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://github.com/TitanBusinessPros/Match-3/raw/main/Match-3%20Logo.png" alt="Match-3 Game Logo" class="game-logo">
        <div class="level-info">
            <div class="level-box">
                <h3>Level</h3>
                <div class="value" id="level">1</div>
            </div>
            <div class="level-box">
                <h3>Score</h3>
                <div class="value" id="score">0</div>
            </div>
            <div class="level-box">
                <h3>Target</h3>
                <div class="value" id="target">500</div>
            </div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress">0%</div>
        </div>
        <div class="grid" id="grid"></div>
        <button onclick="resetGame()">New Game</button>
    </div>

    <div class="level-complete" id="levelComplete">
        <h2>ðŸŽ‰ Level Complete!</h2>
        <p id="levelCompleteText"></p>
        <button onclick="nextLevel()">Next Level</button>
    </div>

    <script>
        const GRID_SIZE = 8;
        const COLORS = 6;
        const gems = ['ðŸ’Ž', 'ðŸ”·', 'â­', 'ðŸ’œ', 'ðŸŒ¸', 'ðŸ”µ'];
        const MAX_LEVEL = 30;
        
        let grid = [];
        let score = 0;
        let level = 1;
        let targetScore = 500;
        let selectedTile = null;
        let isAnimating = false;

        // Background music
        const bgMusic = new Audio('https://github.com/TitanBusinessPros/Match-3/raw/main/Shimmer%20and%20Match.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.3;

        let musicStarted = false;

        function startMusic() {
            if (!musicStarted) {
                musicStarted = true;
                bgMusic.play().catch(e => console.log('Music autoplay prevented:', e));
            }
        }

        // Sound effect for matches using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playMatchSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        function createGrid() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            grid = [];
            
            for (let row = 0; row < GRID_SIZE; row++) {
                grid[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    let color;
                    do {
                        color = Math.floor(Math.random() * COLORS);
                    } while (wouldCreateMatch(row, col, color));
                    
                    grid[row][col] = color;
                    
                    const tile = document.createElement('div');
                    tile.className = `tile color-${color}`;
                    tile.textContent = gems[color];
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    tile.onclick = () => selectTile(row, col);
                    gridEl.appendChild(tile);
                }
            }
        }

        function wouldCreateMatch(row, col, color) {
            // Check horizontal
            if (col >= 2 && grid[row][col-1] === color && grid[row][col-2] === color) {
                return true;
            }
            // Check vertical
            if (row >= 2 && grid[row-1][col] === color && grid[row-2][col] === color) {
                return true;
            }
            return false;
        }

        function selectTile(row, col) {
            if (isAnimating) return;
            
            startMusic(); // Start music on first click
            
            const tile = getTileElement(row, col);
            
            if (selectedTile === null) {
                selectedTile = {row, col};
                tile.classList.add('selected');
            } else {
                const prevTile = getTileElement(selectedTile.row, selectedTile.col);
                prevTile.classList.remove('selected');
                
                if (areNeighbors(selectedTile.row, selectedTile.col, row, col)) {
                    swapTiles(selectedTile.row, selectedTile.col, row, col);
                }
                
                selectedTile = null;
            }
        }

        function areNeighbors(row1, col1, row2, col2) {
            return (Math.abs(row1 - row2) === 1 && col1 === col2) ||
                   (Math.abs(col1 - col2) === 1 && row1 === row2);
        }

        function swapTiles(row1, col1, row2, col2) {
            [grid[row1][col1], grid[row2][col2]] = [grid[row2][col2], grid[row1][col1]];
            updateTiles();
            
            setTimeout(() => {
                const matches = findMatches();
                if (matches.length === 0) {
                    // Swap back if no match
                    [grid[row1][col1], grid[row2][col2]] = [grid[row2][col2], grid[row1][col1]];
                    updateTiles();
                } else {
                    processMatches();
                }
            }, 300);
        }

        function findMatches() {
            const matches = new Set();
            
            // Check horizontal
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE - 2; col++) {
                    const color = grid[row][col];
                    if (color === grid[row][col+1] && color === grid[row][col+2]) {
                        matches.add(`${row},${col}`);
                        matches.add(`${row},${col+1}`);
                        matches.add(`${row},${col+2}`);
                    }
                }
            }
            
            // Check vertical
            for (let col = 0; col < GRID_SIZE; col++) {
                for (let row = 0; row < GRID_SIZE - 2; row++) {
                    const color = grid[row][col];
                    if (color === grid[row+1][col] && color === grid[row+2][col]) {
                        matches.add(`${row},${col}`);
                        matches.add(`${row+1},${col}`);
                        matches.add(`${row+2},${col}`);
                    }
                }
            }
            
            return Array.from(matches).map(pos => {
                const [row, col] = pos.split(',').map(Number);
                return {row, col};
            });
        }

        function processMatches() {
            isAnimating = true;
            const matches = findMatches();
            
            if (matches.length === 0) {
                isAnimating = false;
                return;
            }
            
            // Play match sound!
            playMatchSound();
            
            score += matches.length * 10;
            document.getElementById('score').textContent = score;
            updateProgress();
            
            // Check if level complete
            if (score >= targetScore) {
                setTimeout(() => {
                    showLevelComplete();
                }, 1000);
            }
            
            // Animate matched tiles
            matches.forEach(({row, col}) => {
                const tile = getTileElement(row, col);
                tile.classList.add('matched');
            });
            
            setTimeout(() => {
                // Clear matched tiles
                matches.forEach(({row, col}) => {
                    grid[row][col] = -1;
                });
                
                // Drop tiles
                for (let col = 0; col < GRID_SIZE; col++) {
                    let emptyRow = GRID_SIZE - 1;
                    for (let row = GRID_SIZE - 1; row >= 0; row--) {
                        if (grid[row][col] !== -1) {
                            grid[emptyRow][col] = grid[row][col];
                            if (emptyRow !== row) {
                                grid[row][col] = -1;
                            }
                            emptyRow--;
                        }
                    }
                    
                    // Fill empty spaces
                    for (let row = emptyRow; row >= 0; row--) {
                        grid[row][col] = Math.floor(Math.random() * COLORS);
                    }
                }
                
                updateTiles();
                
                setTimeout(() => {
                    processMatches(); // Check for cascading matches
                }, 300);
            }, 500);
        }

        function getTileElement(row, col) {
            return document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        }

        function updateTiles() {
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const tile = getTileElement(row, col);
                    const color = grid[row][col];
                    if (color !== -1) {
                        tile.className = `tile color-${color}`;
                        tile.textContent = gems[color];
                    }
                }
            }
        }

        function updateProgress() {
            const progress = Math.min((score / targetScore) * 100, 100);
            const progressEl = document.getElementById('progress');
            progressEl.style.width = progress + '%';
            progressEl.textContent = Math.floor(progress) + '%';
        }

        function showLevelComplete() {
            isAnimating = true;
            const modal = document.getElementById('levelComplete');
            const text = document.getElementById('levelCompleteText');
            
            if (level >= MAX_LEVEL) {
                text.textContent = `ðŸŽŠ Congratulations! You've completed all ${MAX_LEVEL} levels! ðŸŽŠ`;
                modal.querySelector('button').textContent = 'Play Again';
            } else {
                text.textContent = `You reached ${score} points! Moving to Level ${level + 1}`;
            }
            
            modal.classList.add('show');
        }

        function nextLevel() {
            const modal = document.getElementById('levelComplete');
            modal.classList.remove('show');
            
            if (level >= MAX_LEVEL) {
                resetGame();
                return;
            }
            
            level++;
            targetScore = level * 500;
            score = 0;
            
            document.getElementById('level').textContent = level;
            document.getElementById('target').textContent = targetScore;
            document.getElementById('score').textContent = score;
            updateProgress();
            
            selectedTile = null;
            isAnimating = false;
            createGrid();
        }

        function resetGame() {
            score = 0;
            level = 1;
            targetScore = 500;
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('target').textContent = targetScore;
            updateProgress();
            selectedTile = null;
            isAnimating = false;
            createGrid();
        }

        function updateProgress() {
            const progress = Math.min((score / targetScore) * 100, 100);
            const progressEl = document.getElementById('progress');
            progressEl.style.width = progress + '%';
            progressEl.textContent = Math.floor(progress) + '%';
        }

        function showLevelComplete() {
            isAnimating = true;
            const modal = document.getElementById('levelComplete');
            const text = document.getElementById('levelCompleteText');
            
            if (level >= MAX_LEVEL) {
                text.textContent = `ðŸŽŠ Congratulations! You've completed all ${MAX_LEVEL} levels! ðŸŽŠ`;
                modal.querySelector('button').textContent = 'Play Again';
            } else {
                text.textContent = `You reached ${score} points! Moving to Level ${level + 1}`;
            }
            
            modal.classList.add('show');
        }

        function nextLevel() {
            const modal = document.getElementById('levelComplete');
            modal.classList.remove('show');
            
            if (level >= MAX_LEVEL) {
                resetGame();
                return;
            }
            
            level++;
            targetScore = level * 500;
            score = 0;
            
            document.getElementById('level').textContent = level;
            document.getElementById('target').textContent = targetScore;
            document.getElementById('score').textContent = score;
            updateProgress();
            
            selectedTile = null;
            isAnimating = false;
            createGrid();
        }

        createGrid();
        updateProgress();
    </script>
</body>
</html>
