<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match-3 Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .container {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .score {
            font-size: 1.5em;
            color: #764ba2;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .grid {
            display: inline-grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 4px;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 15px;
            box-shadow: inset 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .tile {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .tile.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            border: 3px solid white;
        }

        .tile.matched {
            animation: match 0.5s ease-out;
        }

        @keyframes match {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }

        .color-0 { background: linear-gradient(135deg, #ff6b6b, #ee5a6f); }
        .color-1 { background: linear-gradient(135deg, #4ecdc4, #44a08d); }
        .color-2 { background: linear-gradient(135deg, #ffd93d, #f6c744); }
        .color-3 { background: linear-gradient(135deg, #a29bfe, #6c5ce7); }
        .color-4 { background: linear-gradient(135deg, #fd79a8, #e84393); }
        .color-5 { background: linear-gradient(135deg, #74b9ff, #0984e3); }

        button {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíé Match-3 Game</h1>
        <div class="score">Score: <span id="score">0</span></div>
        <div class="grid" id="grid"></div>
        <button onclick="resetGame()">New Game</button>
    </div>

    <script>
        const GRID_SIZE = 8;
        const COLORS = 6;
        const gems = ['üíé', 'üî∑', '‚≠ê', 'üíú', 'üå∏', 'üîµ'];
        
        let grid = [];
        let score = 0;
        let selectedTile = null;
        let isAnimating = false;

        function createGrid() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            grid = [];
            
            for (let row = 0; row < GRID_SIZE; row++) {
                grid[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    let color;
                    do {
                        color = Math.floor(Math.random() * COLORS);
                    } while (wouldCreateMatch(row, col, color));
                    
                    grid[row][col] = color;
                    
                    const tile = document.createElement('div');
                    tile.className = `tile color-${color}`;
                    tile.textContent = gems[color];
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    tile.onclick = () => selectTile(row, col);
                    gridEl.appendChild(tile);
                }
            }
        }

        function wouldCreateMatch(row, col, color) {
            // Check horizontal
            if (col >= 2 && grid[row][col-1] === color && grid[row][col-2] === color) {
                return true;
            }
            // Check vertical
            if (row >= 2 && grid[row-1][col] === color && grid[row-2][col] === color) {
                return true;
            }
            return false;
        }

        function selectTile(row, col) {
            if (isAnimating) return;
            
            const tile = getTileElement(row, col);
            
            if (selectedTile === null) {
                selectedTile = {row, col};
                tile.classList.add('selected');
            } else {
                const prevTile = getTileElement(selectedTile.row, selectedTile.col);
                prevTile.classList.remove('selected');
                
                if (areNeighbors(selectedTile.row, selectedTile.col, row, col)) {
                    swapTiles(selectedTile.row, selectedTile.col, row, col);
                }
                
                selectedTile = null;
            }
        }

        function areNeighbors(row1, col1, row2, col2) {
            return (Math.abs(row1 - row2) === 1 && col1 === col2) ||
                   (Math.abs(col1 - col2) === 1 && row1 === row2);
        }

        function swapTiles(row1, col1, row2, col2) {
            [grid[row1][col1], grid[row2][col2]] = [grid[row2][col2], grid[row1][col1]];
            updateTiles();
            
            setTimeout(() => {
                const matches = findMatches();
                if (matches.length === 0) {
                    // Swap back if no match
                    [grid[row1][col1], grid[row2][col2]] = [grid[row2][col2], grid[row1][col1]];
                    updateTiles();
                } else {
                    processMatches();
                }
            }, 300);
        }

        function findMatches() {
            const matches = new Set();
            
            // Check horizontal
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE - 2; col++) {
                    const color = grid[row][col];
                    if (color === grid[row][col+1] && color === grid[row][col+2]) {
                        matches.add(`${row},${col}`);
                        matches.add(`${row},${col+1}`);
                        matches.add(`${row},${col+2}`);
                    }
                }
            }
            
            // Check vertical
            for (let col = 0; col < GRID_SIZE; col++) {
                for (let row = 0; row < GRID_SIZE - 2; row++) {
                    const color = grid[row][col];
                    if (color === grid[row+1][col] && color === grid[row+2][col]) {
                        matches.add(`${row},${col}`);
                        matches.add(`${row+1},${col}`);
                        matches.add(`${row+2},${col}`);
                    }
                }
            }
            
            return Array.from(matches).map(pos => {
                const [row, col] = pos.split(',').map(Number);
                return {row, col};
            });
        }

        function processMatches() {
            isAnimating = true;
            const matches = findMatches();
            
            if (matches.length === 0) {
                isAnimating = false;
                return;
            }
            
            score += matches.length * 10;
            document.getElementById('score').textContent = score;
            
            // Animate matched tiles
            matches.forEach(({row, col}) => {
                const tile = getTileElement(row, col);
                tile.classList.add('matched');
            });
            
            setTimeout(() => {
                // Clear matched tiles
                matches.forEach(({row, col}) => {
                    grid[row][col] = -1;
                });
                
                // Drop tiles
                for (let col = 0; col < GRID_SIZE; col++) {
                    let emptyRow = GRID_SIZE - 1;
                    for (let row = GRID_SIZE - 1; row >= 0; row--) {
                        if (grid[row][col] !== -1) {
                            grid[emptyRow][col] = grid[row][col];
                            if (emptyRow !== row) {
                                grid[row][col] = -1;
                            }
                            emptyRow--;
                        }
                    }
                    
                    // Fill empty spaces
                    for (let row = emptyRow; row >= 0; row--) {
                        grid[row][col] = Math.floor(Math.random() * COLORS);
                    }
                }
                
                updateTiles();
                
                setTimeout(() => {
                    processMatches(); // Check for cascading matches
                }, 300);
            }, 500);
        }

        function getTileElement(row, col) {
            return document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        }

        function updateTiles() {
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const tile = getTileElement(row, col);
                    const color = grid[row][col];
                    if (color !== -1) {
                        tile.className = `tile color-${color}`;
                        tile.textContent = gems[color];
                    }
                }
            }
        }

        function resetGame() {
            score = 0;
            document.getElementById('score').textContent = score;
            selectedTile = null;
            isAnimating = false;
            createGrid();
        }

        createGrid();
    </script>
</body>
</html>